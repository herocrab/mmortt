### MVP Success
---

- [x] Icon resourced moved to /assets/images
- [x] Setup Godot 4.4 and vsode integration
- [x] Ability to launch multiple scenes indepedently
  - [x] Debugging of multiple instances of the app for network and multiplayer
    - [x] (1) server
    - [x] (2) clients
    - This can be accomplished by running multiple instances of the editor
    - This can be accomoplished by building the app, and running multiple instances with debug flags
    - Further, ports and launch parameters can be added as command-line arguments
- [x] Native logging facilities to file for client + server
  - [x] Uses Logger.write() in a singleton and writes to /log/
- [x] Server is initialize cli with necessary game parameters
  - [x] Add more robust arg parsing with defaults to Launcher.gd
    - [x] Map
    - [x] Number of players per team
    - [x] Number of teams
- [x] Find a state machine for Godot that you like
  - [ ] Using the Finite State Machine plugin for Godot 4
- [ ] Create a server network state machine
  - [ ] Lobby
  - [ ] Simulation
  - [ ] Conclusion
- [ ] Server registers game with Nakama, as authoritative server host
  - All necessary server parameters (map, players, and teams, network state machine) are posted as metadata
  - Use relay model
  - Clients only send to the server, which should be the first client connected
  - Clients need to drop anything not from the server
  - The server will always be the first client connected, because it is the only one that can create rooms
- [ ] Display Room ID, Latency, Metadata as visible in Nakama on server UI
  - [ ] Gated at a lower frequency
- [ ] Server handles moving between states, perhaps based on a timer initially
- [ ] Server loads map data, which will include collisions, and depics blocked tiles
  - [ ] Map is initialized from data referencing map name
  - [ ] Map name includes a scene which auto populates objstructions or blocks
  - [ ] Map terrain/background is simple gray
  - [ ] Obstructions or blocks are black
- [ ] Server init from data file with params needed for Nakama
  - [ ] Server is graphical only and does not have any presentation layer, only command line
- [ ] Client init from data file
- [ ] Create a client network state machine
  - [ ] Lobby
  - [ ] Joining
  - [ ] Simulation
  - [ ] Conclusion
- [ ] Client connects to Nakama, joins server by default (via param in init file)
- [ ] Client specifies it's unit selection and loadout on join
- [ ] Server validates client join message is within rule limits (this can later be token auth)
- [ ] Client can join in-progress, receiving a full state transfer and delta of input tickets
- [ ] Client speeds-up to be in lockstep with server simulation
- [ ] Client sends input only, validated by server and replicated to other clients
- [ ] Prodution ready RTS boxing and clicking selection system
- [ ] Client can send unit movement input, server receives and places into a tick for streaming
- [ ] Client movement utilizes deterministic A* integry based Grid
  - [x] Added SGPhysics2D GDExtension for Fixed Math library
- [ ] Client can issue group formation movements
- [ ] Client uses collision avoidance using tile blocked checking
- [ ] Initial loadout is just square units
- [ ] Collision data for map is read from simple bit-map file, each pixel representing a tile blocking state
- [ ] Client and Server exchange tick hashing to determine if the state is sychronized lockstep simulation
---
- [ ] Start designing the actual core gameplay loop (based on EON and Shattered Galaxy)
- [ ] The unit selection/build client can be separate from the game client, their can be a secure exchange between the two using token auth on teh server

### MVP Tech Stack:
---
- GODOT
- SGPhysics2D
- Nakama

### MVP Technical Design Constraints:
---
- 2D
- Engine Native (logging, debug, etc)
- No UI
- No Unit design, top-down or isometric, just block

